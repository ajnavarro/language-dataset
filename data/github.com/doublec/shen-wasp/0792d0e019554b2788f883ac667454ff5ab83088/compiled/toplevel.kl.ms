(module "compiled/toplevel.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.repl) 0) (define (kl:shen.repl) (begin (kl:shen.credits) (kl:shen.loop))) (export shen.repl) (quote shen.repl))
(begin (register-function-arity (quote shen.loop) 0) (define (kl:shen.loop) (begin (kl:shen.initialise_environment) (begin (kl:shen.prompt) (begin (guard (lambda (E) (kl:shen.toplevel-display-exception E)) (kl:shen.read-evaluate-print)) (kl:shen.loop))))) (export shen.loop) (quote shen.loop))
(begin (register-function-arity (quote shen.toplevel-display-exception) 1) (define (kl:shen.toplevel-display-exception V4125) (kl:pr (kl:error-to-string V4125) (kl:stoutput))) (export shen.toplevel-display-exception) (quote shen.toplevel-display-exception))
(begin (register-function-arity (quote shen.credits) 0) (define (kl:shen.credits) (begin (kl:shen.prhush "\nShen, copyright (C) 2010-2015 Mark Tarver\n" (kl:stoutput)) (begin (kl:shen.prhush (string-append "www.shenlanguage.org, " (kl:shen.app (kl:value (quote *version*)) "\n" (quote shen.a))) (kl:stoutput)) (begin (kl:shen.prhush (string-append "running under " (kl:shen.app (kl:value (quote *language*)) (string-append ", implementation: " (kl:shen.app (kl:value (quote *implementation*)) "" (quote shen.a))) (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\nport " (kl:shen.app (kl:value (quote *port*)) (string-append " ported by " (kl:shen.app (kl:value (quote *porters*)) "\n" (quote shen.a))) (quote shen.a))) (kl:stoutput)))))) (export shen.credits) (quote shen.credits))
(begin (register-function-arity (quote shen.initialise_environment) 0) (define (kl:shen.initialise_environment) (kl:shen.multiple-set (cons (quote shen.*call*) (cons 0 (cons (quote shen.*infs*) (cons 0 (cons (quote shen.*process-counter*) (cons 0 (cons (quote shen.*catch*) (cons 0 (quote ()))))))))))) (export shen.initialise_environment) (quote shen.initialise_environment))
(begin (register-function-arity (quote shen.multiple-set) 1) (define (kl:shen.multiple-set V4127) (cond ((null? V4127) (quote ())) ((and (pair? V4127) (pair? (cdr V4127))) (begin (kl:set (car V4127) (car (cdr V4127))) (kl:shen.multiple-set (cdr (cdr V4127))))) (#t (kl:shen.f_error (quote shen.multiple-set))))) (export shen.multiple-set) (quote shen.multiple-set))
(begin (register-function-arity (quote destroy) 1) (define (kl:destroy V4129) (kl:declare V4129 (quote symbol))) (export destroy) (quote destroy))
(begin (register-function-arity (quote shen.read-evaluate-print) 0) (define (kl:shen.read-evaluate-print) (let ((Lineread (kl:shen.toplineread))) (let ((History (kl:value (quote shen.*history*)))) (let ((NewLineread (kl:shen.retrieve-from-history-if-needed Lineread History))) (let ((NewHistory (kl:shen.update_history NewLineread History))) (let ((Parsed (kl:fst NewLineread))) (kl:shen.toplevel Parsed))))))) (export shen.read-evaluate-print) (quote shen.read-evaluate-print))
(begin (register-function-arity (quote shen.retrieve-from-history-if-needed) 2) (define (kl:shen.retrieve-from-history-if-needed V4141 V4142) (cond ((and (kl:tuple? V4141) (and (pair? (kl:snd V4141)) (kl:element? (car (kl:snd V4141)) (cons (kl:shen.space) (cons (kl:shen.newline) (quote ())))))) (kl:shen.retrieve-from-history-if-needed (kl:_waspvm_at_p (kl:fst V4141) (cdr (kl:snd V4141))) V4142)) ((and (kl:tuple? V4141) (and (pair? (kl:snd V4141)) (and (pair? (cdr (kl:snd V4141))) (and (null? (cdr (cdr (kl:snd V4141)))) (and (pair? V4142) (and (kl:= (car (kl:snd V4141)) (kl:shen.exclamation)) (kl:= (car (cdr (kl:snd V4141))) (kl:shen.exclamation)))))))) (let ((PastPrint (kl:shen.prbytes (kl:snd (car V4142))))) (car V4142))) ((and (kl:tuple? V4141) (and (pair? (kl:snd V4141)) (kl:= (car (kl:snd V4141)) (kl:shen.exclamation)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V4141)) V4142))) (let ((Find (kl:head (kl:shen.find-past-inputs Key? V4142)))) (let ((PastPrint (kl:shen.prbytes (kl:snd Find)))) Find)))) ((and (kl:tuple? V4141) (and (pair? (kl:snd V4141)) (and (null? (cdr (kl:snd V4141))) (kl:= (car (kl:snd V4141)) (kl:shen.percent))))) (begin (kl:shen.print-past-inputs (lambda (X) #t) (kl:reverse V4142) 0) (kl:abort))) ((and (kl:tuple? V4141) (and (pair? (kl:snd V4141)) (kl:= (car (kl:snd V4141)) (kl:shen.percent)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V4141)) V4142))) (let ((Pastprint (kl:shen.print-past-inputs Key? (kl:reverse V4142) 0))) (kl:abort)))) (#t V4141))) (export shen.retrieve-from-history-if-needed) (quote shen.retrieve-from-history-if-needed))
(begin (register-function-arity (quote shen.percent) 0) (define (kl:shen.percent) 37) (export shen.percent) (quote shen.percent))
(begin (register-function-arity (quote shen.exclamation) 0) (define (kl:shen.exclamation) 33) (export shen.exclamation) (quote shen.exclamation))
(begin (register-function-arity (quote shen.prbytes) 1) (define (kl:shen.prbytes V4144) (begin (kl:shen.for-each (lambda (Byte) (kl:pr (make-string 1 Byte) (kl:stoutput))) V4144) (kl:nl 1))) (export shen.prbytes) (quote shen.prbytes))
(begin (register-function-arity (quote shen.update_history) 2) (define (kl:shen.update_history V4147 V4148) (kl:set (quote shen.*history*) (cons V4147 V4148))) (export shen.update_history) (quote shen.update_history))
(begin (register-function-arity (quote shen.toplineread) 0) (define (kl:shen.toplineread) (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (quote ()))) (export shen.toplineread) (quote shen.toplineread))
(begin (register-function-arity (quote shen.toplineread_loop) 2) (define (kl:shen.toplineread_loop V4152 V4153) (cond ((kl:= V4152 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V4152 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V4153 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V4153))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (kl:append V4153 (cons V4152 (quote ())))) (kl:_waspvm_at_p Line V4153))))) (#t (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (if (kl:= V4152 -1) V4153 (kl:append V4153 (cons V4152 (quote ())))))))) (export shen.toplineread_loop) (quote shen.toplineread_loop))
(begin (register-function-arity (quote shen.hat) 0) (define (kl:shen.hat) 94) (export shen.hat) (quote shen.hat))
(begin (register-function-arity (quote shen.newline) 0) (define (kl:shen.newline) 10) (export shen.newline) (quote shen.newline))
(begin (register-function-arity (quote shen.carriage-return) 0) (define (kl:shen.carriage-return) 13) (export shen.carriage-return) (quote shen.carriage-return))
(begin (register-function-arity (quote tc) 1) (define (kl:tc V4159) (cond ((eq? (quote +) V4159) (kl:set (quote shen.*tc*) #t)) ((eq? (quote -) V4159) (kl:set (quote shen.*tc*) #f)) (#t (simple-error "tc expects a + or -")))) (export tc) (quote tc))
(begin (register-function-arity (quote shen.prompt) 0) (define (kl:shen.prompt) (if (assert-boolean (kl:value (quote shen.*tc*))) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "+) " (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "-) " (quote shen.a))) (kl:stoutput)))) (export shen.prompt) (quote shen.prompt))
(begin (register-function-arity (quote shen.toplevel) 1) (define (kl:shen.toplevel V4161) (kl:shen.toplevel_evaluate V4161 (kl:value (quote shen.*tc*)))) (export shen.toplevel) (quote shen.toplevel))
(begin (register-function-arity (quote shen.find-past-inputs) 2) (define (kl:shen.find-past-inputs V4164 V4165) (let ((F (kl:shen.find V4164 V4165))) (if (kl:empty? F) (simple-error "input not found\n") F))) (export shen.find-past-inputs) (quote shen.find-past-inputs))
(begin (register-function-arity (quote shen.make-key) 2) (define (kl:shen.make-key V4168 V4169) (let ((Atom (car (kl:compile (lambda (X) (kl:shen.<st_input> X)) V4168 (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n"))))))) (if (assert-boolean (kl:integer? Atom)) (lambda (X) (kl:= X (kl:nth (+ Atom 1) (kl:reverse V4169)))) (lambda (X) (kl:shen.prefix? V4168 (kl:shen.trim-gubbins (kl:snd X))))))) (export shen.make-key) (quote shen.make-key))
(begin (register-function-arity (quote shen.trim-gubbins) 1) (define (kl:shen.trim-gubbins V4171) (cond ((and (pair? V4171) (kl:= (car V4171) (kl:shen.space))) (kl:shen.trim-gubbins (cdr V4171))) ((and (pair? V4171) (kl:= (car V4171) (kl:shen.newline))) (kl:shen.trim-gubbins (cdr V4171))) ((and (pair? V4171) (kl:= (car V4171) (kl:shen.carriage-return))) (kl:shen.trim-gubbins (cdr V4171))) ((and (pair? V4171) (kl:= (car V4171) (kl:shen.tab))) (kl:shen.trim-gubbins (cdr V4171))) ((and (pair? V4171) (kl:= (car V4171) (kl:shen.left-round))) (kl:shen.trim-gubbins (cdr V4171))) (#t V4171))) (export shen.trim-gubbins) (quote shen.trim-gubbins))
(begin (register-function-arity (quote shen.space) 0) (define (kl:shen.space) 32) (export shen.space) (quote shen.space))
(begin (register-function-arity (quote shen.tab) 0) (define (kl:shen.tab) 9) (export shen.tab) (quote shen.tab))
(begin (register-function-arity (quote shen.left-round) 0) (define (kl:shen.left-round) 40) (export shen.left-round) (quote shen.left-round))
(begin (register-function-arity (quote shen.find) 2) (define (kl:shen.find V4180 V4181) (cond ((null? V4181) (quote ())) ((and (pair? V4181) (assert-boolean (V4180 (car V4181)))) (cons (car V4181) (kl:shen.find V4180 (cdr V4181)))) ((pair? V4181) (kl:shen.find V4180 (cdr V4181))) (#t (kl:shen.f_error (quote shen.find))))) (export shen.find) (quote shen.find))
(begin (register-function-arity (quote shen.prefix?) 2) (define (kl:shen.prefix? V4195 V4196) (cond ((null? V4195) #t) ((and (pair? V4195) (and (pair? V4196) (kl:= (car V4196) (car V4195)))) (kl:shen.prefix? (cdr V4195) (cdr V4196))) (#t #f))) (export shen.prefix?) (quote shen.prefix?))
(begin (register-function-arity (quote shen.print-past-inputs) 3) (define (kl:shen.print-past-inputs V4208 V4209 V4210) (cond ((null? V4209) (quote _)) ((and (pair? V4209) (kl:not (V4208 (car V4209)))) (kl:shen.print-past-inputs V4208 (cdr V4209) (+ V4210 1))) ((and (pair? V4209) (kl:tuple? (car V4209))) (begin (kl:shen.prhush (kl:shen.app V4210 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.prbytes (kl:snd (car V4209))) (kl:shen.print-past-inputs V4208 (cdr V4209) (+ V4210 1))))) (#t (kl:shen.f_error (quote shen.print-past-inputs))))) (export shen.print-past-inputs) (quote shen.print-past-inputs))
(begin (register-function-arity (quote shen.toplevel_evaluate) 2) (define (kl:shen.toplevel_evaluate V4213 V4214) (cond ((and (pair? V4213) (and (pair? (cdr V4213)) (and (eq? (quote :) (car (cdr V4213))) (and (pair? (cdr (cdr V4213))) (and (null? (cdr (cdr (cdr V4213)))) (kl:= #t V4214)))))) (kl:shen.typecheck-and-evaluate (car V4213) (car (cdr (cdr V4213))))) ((and (pair? V4213) (pair? (cdr V4213))) (begin (kl:shen.toplevel_evaluate (cons (car V4213) (quote ())) V4214) (begin (kl:nl 1) (kl:shen.toplevel_evaluate (cdr V4213) V4214)))) ((and (pair? V4213) (and (null? (cdr V4213)) (kl:= #t V4214))) (kl:shen.typecheck-and-evaluate (car V4213) (kl:gensym (quote A)))) ((and (pair? V4213) (and (null? (cdr V4213)) (kl:= #f V4214))) (let ((Eval (kl:shen.eval-without-macros (car V4213)))) (kl:print Eval))) (#t (kl:shen.f_error (quote shen.toplevel_evaluate))))) (export shen.toplevel_evaluate) (quote shen.toplevel_evaluate))
(begin (register-function-arity (quote shen.typecheck-and-evaluate) 2) (define (kl:shen.typecheck-and-evaluate V4217 V4218) (let ((Typecheck (kl:shen.typecheck V4217 V4218))) (if (kl:= Typecheck #f) (simple-error "type error\n") (let ((Eval (kl:shen.eval-without-macros V4217))) (let ((Type (kl:shen.pretty-type Typecheck))) (kl:shen.prhush (kl:shen.app Eval (string-append " : " (kl:shen.app Type "" (quote shen.r))) (quote shen.s)) (kl:stoutput))))))) (export shen.typecheck-and-evaluate) (quote shen.typecheck-and-evaluate))
(begin (register-function-arity (quote shen.pretty-type) 1) (define (kl:shen.pretty-type V4220) (kl:shen.mult_subst (kl:value (quote shen.*alphabet*)) (kl:shen.extract-pvars V4220) V4220)) (export shen.pretty-type) (quote shen.pretty-type))
(begin (register-function-arity (quote shen.extract-pvars) 1) (define (kl:shen.extract-pvars V4226) (cond ((kl:shen.pvar? V4226) (cons V4226 (quote ()))) ((pair? V4226) (kl:union (kl:shen.extract-pvars (car V4226)) (kl:shen.extract-pvars (cdr V4226)))) (#t (quote ())))) (export shen.extract-pvars) (quote shen.extract-pvars))
(begin (register-function-arity (quote shen.mult_subst) 3) (define (kl:shen.mult_subst V4234 V4235 V4236) (cond ((null? V4234) V4236) ((null? V4235) V4236) ((and (pair? V4234) (pair? V4235)) (kl:shen.mult_subst (cdr V4234) (cdr V4235) (kl:subst (car V4234) (car V4235) V4236))) (#t (kl:shen.f_error (quote shen.mult_subst))))) (export shen.mult_subst) (quote shen.mult_subst))
