@i boilerplate.w


\datethis
\def\title{NIXUS}

@* Introduction. The word \title, that means strain in Latin, is the
name of the project to manipulate RF files generated by Ultrasonix
SonixRP system containing ultrasound scan lines in raw format. The
objective of this project is to measure displacements in the material
being scanned using differences in the RF frames obtained during the 
 scan. The header file is structured as follows:

@(nixus.h@>=
#ifndef _NIXUS_H_
#define _NIXUS_H_
@<Macro declarations@>@;
@<Type definitions@>@;
@<Prototypes@>@;
#endif  

@ The program is composed by the following excerpts:
@p
@<Header files@>@;
@<Private variables@>@;
@<Internal functions@>@;
@<Memory management@>@;
@<Functions@>@;
@<Test procedures@>@;

  int main(argc, argv) 
  int argc;
  const char**argv;
  {@+short help = 0;
    Int64 nelems=0;

  if (argc!=3)
    help = 1;
  else {
    if (strncmp(argv[1], "-t", 2)==0) {
      nelems = atol(argv[2]);
      assert(nelems>0);
      test_xcorr(nelems);
    } else 
      help = 1;
  }

  if (help)
    @<Usage@>@;

  return 0;
}

@ Usage helps the user the tasks that can be run and the 
input syntax.

@<Usage@>=
  {
    fprintf(stderr, "%s -t [N]\n", argv[0]);
    fprintf(stderr, "-t => test the cross correlation functions,\n");
    fprintf(stderr, "[N] => number of elements to test.\n");
    exit(-1);
  }

@ Common header files used in the project.

@<Header...@>=
#include <assert.h>
#include <errno.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "nixus.h"

@ We make some aliases for common types to know the wide in bits.

@<Type def...@>=
  typedef unsigned long long int Uint64;
typedef long long Int64;
typedef unsigned int Uint32;
typedef int Int32;
typedef unsigned short Uint16;
typedef short Int16;
typedef unsigned char Uint8;
typedef char Int8;
typedef double Float;

@* Ultrasonix formats and RF structure. There is a rich bunch image formats that can be
  produced by Ultrasonix equipment. The |u_file_header| contains
  information needed to extract data properly. The |type| variable is
  assigned to |u_data_type| and in this project, the type of interest
  is |udtRF|.

@<Type...@>=
  enum u_data_type{
  udtScreen= 0x00000001, /* Compressed file of screen captures */
  udtBPre= 0x00000002, /* Envelope detected B data */
  udtBPost= 0x00000004, /* Interpolated and post-processed B data */
  udtBPost32= 0x00000008, /* Interpolated and post-processed B data 32 bit */
  udtRF= 0x00000010, /* Pre or Post-beamformed RF data */
  udtMPre= 0x00000020, /* Envelope detected and log-compressed M lines */
  udtMPost= 0x00000040,/* Interpolated M line data stored as a single spectrum capture */
  udtPWRF= 0x00000080, /* Doppler RF gate data acquired at the Doppler PRF */
  udtPWSpectrum= 0x00000100, /* Interpolated FFT data stored as a single spectrum capture */
  udtColorRF= 0x00000200, /* Color RF data acquired at the Color PRF with full packet-size */
  udtColorCombined= 0x00000400, /* Interpolated and processed B and color data */
  udtColorVelocityVariance= 0x00000800, /* Interpolated and processed color velocity (Y) 
					   and variance data (X). Variance is power data in 
					   Power Doppler mode  */
  udtElastoCombined= 0x00002000, /* Interpolated and processed B and elastography data */
  udtElastoOverlay= 0x00004000, /* Interpolated and processed elastography data */
  udtElastoPre= 0x00008000, /* Midway processed elastography data before interpolation, 
			       and after RF and strain conversion */
  udtECG= 0x00010000, /*ECG spectrum data */
  udtGPS= 0x00020000, /* GPS co-ordinate data */
  udtPNG= 0x10000000 /* PNG data ?*/
};

typedef struct u_file_header {
  enum u_data_type type; /* data type (can be determined by file extensions) */
  int frames; /* number of frames in file */
  int w;      /* width (number of vectors for raw, 
		image width for processed data) */
  int h;      /* height (number of samples for raw, 
		 image height for processed data) */
  int ss;     /* data sample size in bits */
  int ulx;    /* roi - upper left (x) */
  int uly;    /* roi - upper left (y) */
  int urx;    /* roi - upper right (x) */
  int ury;    /* roi - upper right (y) */
  int brx;    /* roi - bottom right (x) */
  int bry;    /* roi - bottom right (y) */
  int blx;    /* roi - bottom left (x) */
  int bly;    /* roi - bottom left (y) */
  int probe;  /* probe identifier - additional probe information 
		 can be found using this id */
  int txf;    /* transmit frequency in Hz */
  int sf;     /* sampling frequency in Hz */
  int dr;     /* data rate (fps or prp in Doppler modes) */
  int ld;     /* line density (can be used to calculate element spacing if
		 pitch and native number of elements is known  */
  int extra;  /* extra information (ensemble for color RF) */
} U_FileHeader;

@ The {\tt u\_*} macros are defined to access Ultrasonix file header
information, acting as interface and avoiding direct access to
variables.

@<Macro...@>=
#define u_nframes(ufh) ufh->frames
#define u_frame_width(ufh) ufh->w
#define u_frame_height(ufh) ufh->h
#define u_sample_size(ufh) ufh->ss /* sample size in bits */

@ @<Proto...@>=
 extern void u_print_file_header(U_FileHeader*ufh);

@ The |u_print_file_header| function prints the information about
Ultrasonix file and is useful to debug purposes.
@<Functions@>=
void u_print_file_header(U_FileHeader *h){
  printf("Header information:\n");
  printf("|- data type: %d\n",h->type);
  printf("|- number of frames: %d\n",h->frames);
  printf("|- width (number of vectors): %d\n",h->w);
  printf("|- height (number of samples): %d\n",h->h);
  printf("|- data sample size in bits: %d\n",h->ss);
  printf("|- roi - upper left (x): %d\n",h->ulx);
  printf("|- roi - upper left (y): %d\n",h->uly);
  printf("|- roi - upper right (x): %d\n",h->urx);
  printf("|- roi - upper right (y): %d\n",h->ury);
  printf("|- roi - bottom right (x): %d\n",h->brx);
  printf("|- roi - bottom right (y): %d\n",h->bry);
  printf("|- roi - bottom left (x): %d\n",h->blx);
  printf("|- roi - bottom left (y): %d\n",h->bly);
  printf("|- probe identifier: %d\n",h->probe);
  printf("|- transmit frequency (Hz): %d\n",h->txf);
  printf("|- sampling frequency (Hz): %d\n",h->sf);
  printf("|- data rate: %d\n",h->dr);
  printf("|- line density: %d\n",h->ld);
  printf("|- extra information: %d\n",h->extra);
  printf("|- number of bytes per frame: %d\n", 4 + h->w * h->h * h->ss/8);
  printf("|- number of pixels per frame: %d\n", 2 + h->w * h->h);

  return;
}


@* RF. Pre or post-beamformed RF image has the following specification:
\bigskip
  \settabs 16 \columns
    \+&Type: {RF}\cr
  \+&Description: Pre or Post-beamformed RF data\cr
  \+&Organization: Vector\cr
  \+&Bytes per pixel/Format: 16/RF\cr
  \+&Frame size FC + (V * S * 2)\cr
  \+&Extension: .rf\cr
  \+where,\cr
  \+&FC=4 byte header\cr
  \+&V=vectors (number of scan lines)\cr
  \+&S=samples (number of incident pulses per scan line line represented by 2-byte header).\cr

\bigskip
RF file is loaded into memory as |RF|, saving the |file_header|
information and the pixels into |data|. The |area| is part of a memory
management scheme used by SGB (Stanford GraphBase). The concept of
type |Area| is simple and powerful because all memory allocations are
performed using |gb_typed_alloc| function, also from SGB, allowing
safe and unique deallocation.

@<Type...@>=
typedef struct rf {
  U_FileHeader *file_header; /* header with file and RF information */
  pixel_t *data; /* array containing pixel values */
  struct arena *arena;
} RF;

@ Each RF pixel is 2-byte size (16 bits). |MAX_PIX_VAL| ($2^{15}-1$)
  is the maximum pixel value that can be assigned to RF sample. The
  minimum pixel value is 32,767 ($2^{15}$). This range is due the type
  assigned to |pixel_t|. The type can be changed according to the
  pixel manipulation needs, but a careful attention must be paid to
  assigned correct values for limits.

@<Macro...@>=
#ifdef pixel_t
#undef pixel_t
#endif
#define pixel_t Uint16
#define MAX_PIX_VAL 65535


@ Some macros to access RF information are defined to expose a clean
accession interface.

@<Macro...@>=
#define RF_FRAME_HEADER_SZ 4 /* 4-byte frame header */
#define RF_FRAME_HEADER_NPIX 2 /* number of pixels in the frame header (each pixel is 2-byte) */
#define rf_frame_nvectors(rf) u_frame_width(rf->file_header)
#define rf_frame_nsamples(rf) u_frame_height(rf->file_header)
#define rf_nframes(rf) u_nframes(rf->file_header)
/* number of pixels in the frame */ 
/* not taking into account frame header */
#define rf_frame_data_npixels(rf) \
  (rf_frame_nvectors((rf))*rf_frame_nsamples((rf)))
    
#define rf_frame_npixels(rf) \/* number of pixels in the frame $\rightarrow$ header + data */
     (2 + rf_frame_data_npixels((rf)))
  
#define rf_frame_nbytes(rf) (rf_frame_npixels(rf)*2) /* in bytes */
#define rf_npixels(rf) ((rf_frame_npixels(rf))*rf_nframes(rf))
#define rf_nbytes(rf) (rf_npixels(rf)*sizeof(pixel_t)) /* in bytes */

@* {RF data}.The lines are recorded as showed in the
Figure~1, where each sample is recorded as it arrives, and
after all, the map must be reshaped where the coordinate $(0,1)$
becomes $(1,0)$, for example, reconstructing the RF data as it is
  formed after processing in B-mode. (See notes)
  
@ A pixel at position $(x, y)$ on frame number $FN$ is obtained by:

  $$FN = npp + npfh + x\times nsv + y,$$

where
\settabs 16\columns
\+&$npp$& -  &number of pixels per frame;\cr
\+&$npfh$& -  &number of pixels in the frame header;\cr
\+&$nsv$& - &number of samples per vector;\cr
\+&$x$& - &x position;\cr
\+&$y$& - &y position.\cr
\bigskip

  The pixel value can be obtained by using |rf_pixel| macro, and all information needed
  is available in the RF file header. Remember the value on y axis goes from $0$ to $h$,
  from top to bottom, a common standard when dealing with images to simplify the 
  image transverse reasoning. (See notes)


  The |rf_pixel_prt| returns the address of the pixel in the $(x,y)$
  position of the |frame_id|. The mapping of RF as showed in
  Figure~1 (scan lines) to RF as showed in
  Figure~2 (image) is done to access the right pixel at
  the desired position.

@<Macro...@>=
#define rf_pixel_ptr(rf, frame_no, x, y) (rf->data \
  + rf_frame_npixels(rf)*frame_no	       \
  + RF_FRAME_HEADER_NPIX	\
  + (x)*rf_frame_nvectors((rf))			\
  + (y))
#define rf_pixel(rf, frame_no, x, y) *rf_pixel_ptr((rf), (frame_no), (x), (y))


@ Private variable |cur_rf| is used to maintain a internal global
pointer to pass |RF| through the program.
@d MAX_NRF 0x200
@<Private...@>=
  static Uint32 cur_nRF = 0;
  static RF cur_rf[MAX_NRF];


@ |rf_new| increments the current number of RF structures in the
  |cur_rf| array, and after assertinf the index of the array is not
  greater than maximum number of RF allowed, it allocates memory to 
  |arena| memory scheme. Using |arena| scheme, it also allocates 
  memory to file header field.

@<Functions@>=
RF *rf_new () 
  {@+Uint32 n = increment_number_of_RFs();
        
    assert(n < MAX_NRF);

    cur_rf[n].arena = arena_new();
    assert((cur_rf[n]).arena);

    cur_rf[n].file_header = arena_alloc(cur_rf[n].arena, sizeof(U_FileHeader));

  return &cur_rf[n];
}

@ |increment_number_of_RF| augments the current index of the 
|cur_rf| array.

@<Internal...@>=
  static Uint32 increment_number_of_RFs() {
    return cur_nRF++;
  }

@ |rf_free| cleans up |RF| structure using |arena| memory
management scheme.

@<Functions@>=  
void rf_free(rf)
     RF *rf;
{
  assert(rf);

  arena_dispose(&(rf->arena));    
  free(rf);
}

@ |rf_read| opens a file containg |RF| data and fills
the |RF| structure.

@<Functions@>=
RF *rf_read(fn)
const char*fn; /* RF file name */
{
  FILE *fp;
  RF *rf;

  assert(fn);
  rf = rf_new();
  
  if ((fp = fopen(fn, "rb")) == NULL)
      die("Could not open the file %s: %s\n", fn, strerror(errno));

  @<Extract and print RF file header@>@;
  @<Allocate memory and fill with RF data@>@;
  
  fclose(fp);
    
  assert(rf_nframes(rf)>0);

  return rf;
  
}

@ File header is read to extract information about the RF data
  incorporated, then it is printed to inform how data is structured.

@<Extract and print RF file header@>=
      fread(rf->file_header, sizeof(U_FileHeader), 1, fp);
if (rf->file_header->type != udtRF)/* verify if the file is RF type 0x10 = 16 */
  die("The file %s seems not to be in RF format.\n", fn);
#ifndef NDEBUG
u_print_file_header(rf->file_header);
#endif

@ A quantity |data_sz| of memory for |rf_data| is allocated in the heap and 
  filled with binary data obtained from RF file. The |rf_data| contains
  all RF frame headers and frames.

@<Allocate memory and fill with RF data@>=
  debug("Alocating %lu bytes to RF data.\n", rf_nbytes(rf));
  rf->data = (pixel_t *)arena_alloc(rf->arena, rf_nbytes(rf));

if (!rf->data) {
  rf_free(rf);
  die("Could not allocate memory.");
 }
fread(rf->data, rf_nbytes(rf), 1, fp);


@* Memory allocation. Due the frequent use of dynamic memory
allocation, we implemented a memory management scheme to allow a
centralized source of access to the chunks of memory. This scheme is
known as |arena|, it was described by David R. Hanson in the 1997
edition of the book ``C Interfaces and Implementations'' at page 89.

This scheme avoid the need to allocate and free in the same excerpt of
code, and it helps to avoid the dangling pointer problem, when a pointer
is deallocated before its lifetime ends. All memory is freed at the
same time in batch mode.

@<Type def...@>=
  typedef struct arena {
    struct arena *prev;
    Uint8 *avail;
    Uint8 *limit;
  } Arena;

@ @<Proto...@>=
extern  Arena *arena_new(void);
extern void arena_dispose(Arena**);
extern void *arena_alloc(Arena*, Int64 nbytes);
extern void *arena_calloc(Arena*, Int64 count, Int64 nbytes);
extern void arena_free(Arena*);

@ The |arena_new| function is used to create and initialize 
the |arena| structure.

@<Memory...@>=
  Arena *arena_new()
{@+Arena *arena;
  arena = malloc(sizeof(Arena));
  assert(arena);

  arena->prev = NULL;
  arena->limit = arena->avail = NULL;
  return arena;
}

@ The |arena_alloc| allocates memory using the |arena|
scheme.

@<Memory...@>=
  void *arena_alloc(arena, nbytes) 
  Arena *arena;
Int64 nbytes;
{@+assert(arena);
  assert(nbytes>0);
 
@<Round |nbytes| up to the alignment boundary@>@;
  while (nbytes > arena->limit - arena->avail) {
    @<Get a new chunk@>@;
  }
  
  arena->avail += nbytes;
  return arena->avail - nbytes;
}

@ @<Type def...@>=
      union align {
	int i;
	long l;
	long *lp;
	void *p;
	void (*fp)(void);
	float f;
	double d;
	long double ld;
      };

@ @<Get a new chunk@>=
      Arena *ptr;
Uint8 *limit;
@<A new chunk is assigned to |ptr|@>@;
*ptr = *arena;
arena->avail = ((Uint8 *)(union header *)ptr + 1);
arena->limit = limit;
arena->prev = ptr;

@ @<Type def...@>=
  union header {
    Arena *b;
    union align a;
  };

@ @<Internal...@>=
  static Arena *freechunks;
static Int64 nfree;

@ @<A new chunk is assigned to |ptr|@>=
  if ((ptr=freechunks) != NULL) {
    freechunks = freechunks->prev;
    nfree--;
    limit = ptr->limit;
  } else {
    Int64 m = sizeof(union header) + nbytes + 10*1024;
    ptr = calloc(1,m);
    assert(ptr);
    limit = (Uint8 *)ptr + m;
  }

@ @<Round |nbytes| up to the alignment boundary@>=
      nbytes = ((nbytes + sizeof(union align) - 1)/
		(sizeof(union align)))*(sizeof(union align));

@ @<Memory...@>=
  void *arena_calloc(arena, count, nbytes)
  Arena *arena;
Int64 count, nbytes;
{@+void *ptr;
  
  ptr = arena_alloc(arena, count*nbytes);
  return ptr;
}

@ |arena_free| cleans up all memory allocated in |arena| at once. 
We do not need to worry about allocate memory lifetime.

@<Memory...@>=
      void arena_free(arena) 
      Arena *arena;
{
  assert(arena);
  
  while (arena->prev) {
    Arena *tmp = arena->prev;
    @<Free the chunk described by |arena|@>@;
    arena = tmp;
  }
  assert(arena->limit == NULL);
  assert(arena->avail == NULL);
}

@ @d THRESHOLD 10
@<Free the chunk described by |arena|@>=
      if (nfree < THRESHOLD) {
	arena->prev->prev = freechunks;
	freechunks = arena->prev;
	freechunks->limit = arena->limit;
      } else
	free(arena->prev);

@ @<Memory...@>=
  void arena_dispose(apt) 
  Arena **apt;
      {
	assert(apt);
	assert(*apt);
	
	arena_free(*apt);
	free(apt);
	*apt=NULL;
      }


@* Normalized Cross-Correlation (NCC). NCC is frequently used as a
method to determine correlation between two data series. This method
is used to calculate the pairwise correlation between RF
sub-frames. The reference data is compared with template, where the
template in our case is the RF images acquired normally after some
deformation is induced in the sample exposed to ultrasound pulse. 
The Equation~1 presents the original method to calculate NCC ($r_{xy}$).

$$
\def\dt{{\Delta~t}}
\def\average#1{\overline{#1}}
r_{xy}= {
  {\sum\limits_{i=1}^{n}
   (x_i-\average{x})(y_i- \average{y})
  }\over
  {\sqrt{\sum\limits_{i=1}^{n}(x_i-\average{x})^2
	 \times\sum\limits_{i=1}^{n}(y_i-\average{y})^2}}
}\eqno(1)
$$

\settabs 16 \columns
\+ where\cr
\+&$r_{xy}$~-~normalized cross-correlation;\cr
\+&$i$~--~index; \cr
\+&$x$~--~|REFERENCE| signal in pixel intensity;\cr
\+&$y$~--~|TARGET| signal to be compared with the reference in pixel intensity.\cr

\bigskip The problem with Equation (1) is that requires two p asses to
calculate the correlation. Equation (2) is less intuitive but it
requires only one pass to acomplish the task. The equation was
obtained from the book ``Introduction to 64 Bit Intel Assembly
Language Programming for Linux: Second Edition'' at chapter 19 (Kindle
edition), by Ray Seyfarth.

$$
\def\den#1{{\sqrt{n\sum #1_i^2-(\sum #1_i)^2}}}
r_{xy} = {
       {n\sum x_iy_i-\sum x_i\sum y_i}
       \over
       {\den{x}\den{y}}
}\eqno(2)
$$

\noindent where the variables have the same meaning of Equation (1).


@ Using the Equation~(2), five sums are needed to pass the data:
$x_i$, $y_i$, $x_i^2$, $y_i^2$, $x_iy_i$.

@<Proto...@>=
  extern Float xcorr(Int64*x, Int64*y, Int64 n);
	
@ @d EPSILON 0.000001

@<Functions@>=
  Float xcorr(x, y, n)
  Int64 *x, *y, n;
{@+register Int64 i;
  register Int64 sum_x=0, sum_y=0, sum_xx=0, sum_yy=0, sum_xy=0;
  Float den, num;

  assert(x && y);

  for (i = 0; i < n ; i++) {
    register Int64 xval = *(x+i);
    register Int64 yval = *(y+i);
    sum_x += xval;
    sum_y += yval;
    sum_xx += xval * xval;
    sum_yy += yval * yval;
    sum_xy += xval * yval;
  }

  num = ((Float)(n*sum_xy-sum_x*sum_y));
  den = sqrt((n*sum_xx-sum_x*sum_x)* 
	     (n*sum_yy-sum_y*sum_y));

  if (!(fabs(den-den)>EPSILON))
    return 1.0;
  else
    return num/den;
} 

@* Optimizations. The following prototypes are foreign to {\sc CWEB},
and for this reason they are generated in separated files ({\tt
arch/x86-64/xcorr\_*.asm}).  The files contain instructions to
calculate normalized cross correlation using Intel x86-64 assembly
language, more specifically the {\tt yasm} assembler. 

The reason to use assembly language is not because we think we can
beat the compiler in the assembly code generated from {\sc C} code,
but because some operations and resources to process multiple data
implemented in the processor, sometimes is not implemented as
optmization in the compiler.

The first implementation of cross correlation using Intel x86-64
assembly ({\tt arch/x86-64/xcorr\_sse.asm}) takes advantage of
Streaming SIMD (single instruction, multiple data) Extensions (SSE) to
perform some operations on multiple data. The second one ({\tt
arch/x86-64/xcorr\_avx.asm}) uses the Intel Advanced Vector Extensions
(AVX). The third one ({\tt arch/x86-64/xcorr\_nat}) uses SSE2 and it
contains instructions to work with integers.


The assembly code in the files was described by Ray Seyfarth in the
book ``Introduction to 64 Bit Intel Assembly Language Programming for
Linux: Second Edition'' at chapter 19 (Kindle edition).  \smallskip

@<Proto...@>=
extern Float xcorr_sse(Float x[], Float y[], Uint64 n);
extern Float xcorr_avx(Float x[], Float y[], Uint64 n);


@ |xcorr_nat| function handles integers.

@<Proto...@>=
  extern Float xcorr_nat(Int64 x[], Int64 y[], Int64 n);


@* x$86$-$64$-Bit Assembly. This section contains technical information 
and tips for optimizing x86-64 assembly code. It is a difficult task
to mantain the document updated because changes in the processor are 
very fast, but we intend to put some good tips and techniques that 
are more stable.

128-Bit SIMD Integer Instructions Set 2 (SSE2) was used to
implement |xcorr_nat| function.  The XMMMx-registers introduced in the
SSE2 instruction set extensions store 128-bit that can be aligned as
follows:
\smallskip
\vbox {
\settabs 16\columns
\+&1$\times$ 128-bit raw integer&\cr  
\+&2$\times$ 64-bit integer&\cr
\+&4$\times$ 32-bit integer&\cr
\+&8$\times$ 16-bit integer&\cr
\+&16$\times$ 8-bit integer&\cr
\+&2$\times$ 64-bit floating point values&\cr
\+&4$\times$ 32-bit floating point values&\cr
}

\bigskip

\def\beginasm{
        \begingroup\smallskip
        \tt\settabs 8\columns
}
\def\endasm{\bigskip\endgroup}

The instructions used in the assembly code to calculated normalized
cross correlation are described as follows:
	
@ {\tt MOVDQA} moves aligned double quadword, as an example,
the instruction

\beginasm
     \+&MOVEQDA xmm2/m128, xmm1;\cr
\endasm

fetchs the content of {\tt xmm1} and moves it to {\tt xmm2}. 
The {\tt MOVDQA} operation corresponds to:

\beginasm
        \+&xmm2 $\leftarrow$ xmm1;\hfill\cr
\endasm

@ {\tt PADDQ} instruction with 128-Bit operands

\beginasm
        \+&PADDQ xmm1, xmm2/m128;\cr
\endasm

\noindent adds packed quadword integers xmm2/m128 to xmm1. 
The {\tt PADDQ} corresponds to:


\beginasm
        \+&DEST[63-0] $\leftarrow$ DEST[31-0] + SRC[31-0];\cr
        \+&DEST[127-64] $\leftarrow$ DEST[95-64] + SRC[95-64];\cr
\endasm

@ {\tt PMULUDQ} instruction with 128-Bit operands

$$\vbox{\+\tt PMULUDQ xmm1, xmm2/m128;\cr}$$

\noindent multiplies packed unsigned doubleword integers in {\tt xmm1} 
 packed by the unsigned doubleword integers in {\tt xmm2$/$m128}, and store 
  quadword results {\tt xmm1}. The {\tt PMULUDQ} operation corresponds
  to:

\beginasm
        \+&DEST[63-0] $\leftarrow$ DEST[31-0] * SRC[31-0];\cr
        \+&DEST[127-64] $\leftarrow$ DEST[95-64] * SRC[95-64];\cr
\endasm

@ The instruction

\beginasm
        \+&HADDPD xmm0, xmm0;\cr
\endasm

 is equivalent to

\beginasm
        \+&xmm0[63-0] $\leftarrow$ xmm0[63-0] + xmmo[127-64];\cr
\endasm

and it stores the addition of double-precision low and high quadwords in the low 
quadword in the destination operand.

@ The instruction

\beginasm
        \+&CVTDQ2PD xmm1, xmm2/m128;\cr
\endasm

converts two packed signed doubleword integers from {\tt xmm2/m128} to 
two packed double-precision floating point values in {\tt xmm1}. It is
equivalent to:

\beginasm
        \+&xmm1[63-0] $\leftarrow$ xmm2[31-0];\cr
        \+&xmm1[127-64] $\leftarrow$ xmm2[63-32];\cr
\endasm


@* Normalized cross correlation tests. |xcorr_*| functions 
are tested in terms of number of cycles spent to accomplish 
the task. ({\tt TODO: insert assertion test})

@<Test...@>=
static void test_xcorr(Int64 nelems);
static void test_xcorr(n)
     Int64 n; /* number of elements to calculate cross correlation */
{@+Uint64 i;
  register Int64 *x, *y;
  FILE *fp;
  const char *fn = "test-xcorr.dat";

  assert(n>0);
  
  x = (Int64 *)calloc(n, sizeof(Int64));
  y = (Int64 *)calloc(n, sizeof(Int64));

  for (i=0; i<n; i++) {
    *(x+i) = 1+i;
    *(y+i) = 1+2*i;
  }

  if ((fp=fopen(fn, "aw"))==NULL)
    die("Could not open %s\n.", fn);
  
  fprintf(fp, "%lld\t", n);
  do_xcorr(fp, xcorr_nat, x, y, n);
  fprintf(fp, "\t");
  do_xcorr(fp, xcorr, x, y, n);
  fprintf(fp, "\n");

  
  fclose(fp);
  if (x)
    free(x);
  if (y)
    free(y);
}

@ The |rdtsc| function get the current number of cycles of the 
processor. The difference is used as measure of efficiency.

@<Internal...@>=
  inline Uint64 rdtsc();
inline Uint64 rdtsc() { 
  Uint32 lo, hi; 
  __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi)); 
  return (Uint64)hi << 32 | lo; 
}



@* Sub-frame matching. Sub-frames are divisions of the |REFERENCE| RF
image that are used to search the most correlate region in the image
used as |TEMPLATE|. The |reference_id| indicates the number of the RF
frame to be used as |REFERENCE|, and the |target_id| is the same to
|TARGET| image. The |ratio| type set the value to divide the columns
and lines to obtain the sub-frames. Sub-frame is not called region of
interest (ROI) to avoid collision with the same term used in the RF
file header. (here we prepare the file to accommodate block matching 
of images)

|REFERENCE| image index is assigned to $0$ and |TARGET| to 1. The
|REFERENCE| image is divided into sub-frames that are regions to be
tracked against the |TARGET| to find the differential strain. The
|struct coordinate| is a wrapper to $(x,y)$ coordinates.

@<Type...@>=
 enum {REFERENCE=0, TARGET=1};
typedef struct coordinate {
    Uint64 x;
    Uint64 y;
  } Coordinate;

typedef struct subframe {
   Uint64 frame_id; /* frame number */
   struct coordinate top_left; /* top left coordinate of sub-image */
   struct coordinate bottom_right; /* bottom right coordinate of sub-image */
 } SubFrame;

@ @<Internal...@>=
  static void subframe_new(sf, frame_id, top_left, bottom_right)
  SubFrame *sf;
  Uint64 frame_id;
  struct coordinate top_left, bottom_right; /* top-left and bottom-right coordinates */
  {
    assert(sf != NULL);
    assert(top_left.x<bottom_right.x);
    assert(top_left.y<bottom_right.y);
    
    sf->frame_id = frame_id;
    sf->top_left = top_left;
    sf->bottom_right = bottom_right;
  }

@ @<Proto...@>=
     extern void rf_match(RF*); /* pending... */

@* Portable Gray Map (PGM). PGM is used when there is a need to
inspect pixel value to debug the algorithms.

@<Internal...@>=
 static void pgm_write(rf, frame_no, output_filename)
    RF *rf; /* pointer to RF data */
    Uint16 frame_no; /* frame to be written */
    char *output_filename; /* file name to output */

  { FILE *fp;
    register Uint64 nrows, ncols; /* number of rows and columns of image */
    register Uint64 x, y; /* general purpose indices */
    pixel_t p;
    Float v;
    assert (rf);
    assert (output_filename);
    assert (rf->file_header);
    assert (rf->data);
    assert (frame_no >= 0);
    assert (frame_no < rf_nframes(rf));
    nrows = rf_frame_nsamples(rf);
    ncols = rf_frame_nvectors(rf);
    fp = fopen(output_filename, "w");
    if (!fp)
      die("Could not open \"%s\" file for writing.", output_filename);

    fprintf (fp, "P2\n");
    fprintf (fp, "# frame %u/%u\n", frame_no+1, rf_nframes(rf));
    fprintf (fp, "%llu %llu\n", ncols, nrows);
    fprintf (fp, "%d\n", MAX_PIX_VAL);

    for (y = 0; y < nrows; y++) {
      for (x = 0; x < ncols; x++)  {
	p = (pixel_t) rf_pixel(rf, frame_no,  x, y);
	
	v = (p + MAX_PIX_VAL)/65535.0 * 255.0;
	
	fprintf (fp, "%f\t%d\t", v, p);
      }
      fprintf(fp, "\n");
    }
    
    fclose(fp);
    return;
  }



@ Common includes.

@<Header...@>=
#include <stdio.h>
#include <stdlib.h>
#include "nixus.h"

@ Time.

@<Header...@>=
#include <sys/times.h>

@ @<Internal...@>=
  static double time();
static double time() 
{
struct tms t;
times(&t);
return (t.tms_utime+t.tms_stime)/100.0;
}

@ @<Internal...@>=
  static void do_xcorr(FILE *fp, Float (*xcorr_func)(Int64*x,Int64*y,Int64 n), 
			 Int64 *x, Int64 *y, Int64 n);
static void do_xcorr(fp, xcorr_func, x, y, n)
     FILE *fp; /* output data */
     Float (*xcorr_func)(Int64 *x, Int64 *y, Int64 n);
     Int64 *x, *y;
     Int64 n;
{@+Float c;
  Float start, end;
  Uint64 t0, t1;

  assert(fp);

  start = time();
  t0 = rdtsc();
  c = xcorr_func(x, y, n);
  t1 = rdtsc();
  end = time();
  
  printf("%llu numbers, xcorr=%f\n", n, c);
  printf("elapsed time=%f\n", end-start);
  fprintf(fp, "%llu", t1-t0);
}


@* Utilities. The macro |die| shows a message with the line number,
file and function names, and aborts the execution of the program. If
|NDEBUG| macro is defined, no error is evaluated and no |debug|
information is printed.

@<Macro...@>=
#ifdef NDEBUG
#define debug(format, ...) ;
#else
#define __print_location()    fprintf(stdout, "%d:%s->%s(): ", __LINE__, __FILE__, __FUNCTION__)
#define debug(format, ...) __print_location();	\
  fprintf(stdout, format, ## __VA_ARGS__ )
#define die(format, ...)  __print_location();			\
  fprintf(stderr, format, ## __VA_ARGS__);			\
  exit(-1)		
#endif



@* TODO. The following tasks are pending, and the priority are
assigned in the parentheses.

\item{(0)} Refine the |rf_match| function to search a reasonable target
 image region, using block matching.
\item{(2)} Add multi-thread instructions in the target frames matching to take
 advantage of multi-core architecture of current processors.
\item{(4)} Specify the output coding to elastography map. 

@* Index.

